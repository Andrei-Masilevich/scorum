<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Scorum: Plugin readme</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Scorum
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Plugin readme </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The latest release (TODO: Version number) exposes the plugin architecture. Each plugin has full access to the database and can change node behavior. Each plugin may also provide API's.</p>
<h1><a class="anchor" id="autotoc_md43"></a>
The debug_node plugin</h1>
<p>The goal of the <code>debug_node</code> plugin is to start with the live chain, then easily simulate future hypothetical actions. The plugin simulates changes to chain state. For example, you can edit an account's balances and signing keys to enable performing (simulated) actions with that account.</p>
<h1><a class="anchor" id="autotoc_md44"></a>
Why this isn't unsafe</h1>
<p>Anyone (even you!) can edit their account to contain 1 million SCORUM. It's really impossible for the developers to physically stop you from editing the memory/disk of your own computer to make your local node think any account balance is any amount, so you can "give" yourself 1 million SCORUM. Just like it's really impossible for your bank to physically stop you from writing any numbers you'd like when balancing your checkbook, so you can "give" yourself 1 million dollars.</p>
<p>But you have no way to control what other nodes do (or what your bank's clerks and computer systems do). They do their own bookkeeping and keep track of what your real balance is (without all the fake SCORUM or fake dollars you "gave" yourself). So you can believe whatever you want about your balance and rewrite the rules of your own bookkeeping system to show you whatever balance you want to be shown, but as soon as you try to actually spend SCORUM (or dollars) that you don't actually have, you'll be stopped because every other node on the network is a system you don't control that's keeping the books properly (without all your edits to give yourself extra funds), and they do their own verification of every transaction and will suppress any that doesn't have sufficient balance and a proper cryptographic signature.</p>
<h1><a class="anchor" id="autotoc_md45"></a>
Why this is useful for debugging</h1>
<p>Say you've written some code for a hardfork &ndash; some new feature or a bugfix that activates on every node at a certain time or a certain block number &ndash; e.g. January 1 at midnight (hypothetical date). One basic question to ask is, if we apply that code to the current chain, does block production continue as expected on January 1? If the process segfaults, or block production hangs, or nobody can do transactions after January 1, those are certainly showstopping problems that need to be fixed before your code is ready to be included in a release. So to test that it would be nice to speed up time and simulate creating blocks to January 1, but you don't have any witness private keys. With <code>debug_node_plugin</code> you can simulate changing of witness keys to a key you control and produce as many blocks as you'd like.</p>
<h1><a class="anchor" id="autotoc_md46"></a>
Example usage</h1>
<p>Let's say we want to get the history of the chain. The first order of business is to save the blocks from a running node: </p><pre class="fragment">cp -Rp datadir/blockchain/database/block_num_to_block /mydir/myblocks
</pre><p> Then create a new node with an empty datadir and no seed nodes. (No seed nodes means it won't participate in the p2p network and won't receive any blocks except the ones we'll explicitly tell it to load later.) We enable the debug node and allow access to its API to anyone: </p><pre class="fragment"># no seed-node in config file or command line
p2p-endpoint = 127.0.0.1:2001       # bind to localhost to prevent remote p2p nodes from connecting to us
rpc-endpoint = 127.0.0.1:8090       # bind to localhost to secure RPC API access
enable-plugin = witness blockchain_history debug_node
public-api = database_api login_api debug_node_api
</pre><p> The <code>public-api</code> section lists API's accessible to the RPC endpoint. Since (as explained above) the <code>debug_node_api</code> allows the database to be edited in ways that cause the node to report simulated chain state to clients and fail to sync to the real network, RPC should not be accessible to the entire internet when the <code>debug_node_api</code> is in the list of public API's.</p>
<p>The API's configured with <code>public-api</code> are assigned numbers starting at zero. So the <code>debug_node_api</code> is callable by API number 2 (TODO: Explain about resolving names to API's and get it working).</p>
<p>The API provides the following methods (see <code><a class="el" href="debug__node__api_8hpp.html">libraries/plugins/debug_node/include/scorum/plugins/debug_node/debug_node_api.hpp</a></code> for these definitions): </p><pre class="fragment">void debug_push_blocks( std::string src_filename, uint32_t count );
void debug_generate_blocks( std::string debug_key, uint32_t count );
void debug_update_object( fc::variant_object update );
void debug_stream_json_objects( std::string filename );
void debug_stream_json_objects_flush();
</pre><p> Okay, let's run <code>scorumd</code>. It should start immediately with no blocks. We can ask it to read blocks from the directory we saved earlier: </p><pre class="fragment">curl --data '{"jsonrpc": "2.0", "method": "call", "params": [2,"debug_push_blocks",["/mydir/myblocks", 1000]], "id": 1}' http://127.0.0.1:8090/rpc
</pre><p> As expected we now have 1000 blocks: </p><pre class="fragment">curl --data '{"jsonrpc": "2.0", "method": "call", "params": [0,"get_dynamic_global_properties",[]], "id": 2}' http://127.0.0.1:8090/rpc
</pre><p> It queries the directory for blocks after the current head block, so we can subsequently load 500 more: </p><pre class="fragment">curl --data '{"jsonrpc": "2.0", "method": "call", "params": [2,"debug_push_blocks",["/mydir/myblocks", 500]], "id": 3}' http://127.0.0.1:8090/rpc
</pre><p> Let's generate some blocks: </p><pre class="fragment">curl --data '{"jsonrpc": "2.0", "method": "call", "params": [2,"debug_generate_blocks",["5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3",5]], "id": 4}' http://127.0.0.1:8090/rpc
</pre><p> As you can see, the <code>debug_node</code> performs a local edit of each witness's public key: </p><pre class="fragment">curl --data '{"jsonrpc": "2.0", "method": "call", "params": [0,"get_witness_by_account",["dantheman4"]], "id": 5}' http://127.0.0.1:8990/rpc
curl --data '{"jsonrpc": "2.0", "method": "call", "params": [0,"get_witness_by_account",["thisisnice4"]], "id": 6}' http://127.0.0.1:8990/rpc
curl --data '{"jsonrpc": "2.0", "method": "call", "params": [0,"get_dynamic_global_properties",[]], "id": 7}' http://127.0.0.1:8090/rpc
</pre><p> The important information in the above is: </p><pre class="fragment">... "signing_key":"SCR6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV" ...
... "head_block_number":1505 ...
</pre><p> which demonstrates the witness keys have been reset and the head block number has been advanced with new blocks. The blocks are signed by the above private key, and the database is edited to set the block signing key of the scheduled witnesses accordingly so the node accepts the simulated signatures as valid.</p>
<p>If we want to take control of an account we can do so by editing its key with <code>debug_update_object</code> command like this: </p><pre class="fragment">curl --data '{"jsonrpc": "2.0", "method": "call", "params": [0,"lookup_account_names",[["scorum"]]], "id": 8}' http://127.0.0.1:8090/rpc    # find out ID of account we want is 2.2.28
curl --data '{"jsonrpc": "2.0", "method": "call", "params": [2,"debug_update_object",[{"_action":"update","id":"2.2.28","active":{"weight_threshold":1,"key_auths":[["SCR6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV",1]]}}]], "id": 9}]' http://127.0.0.1:8090/rpc
</pre><p> Now that we've reset its key, we can take control of it in the wallet: programs/cli_wallet/cli_wallet -w debug_wallet.json -s ws://127.0.0.1:8090 set_password abc unlock abc import_key 5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3 list_my_accounts transfer scorum dantheman "1.234 SCORUM" "make -j100 money" true list_my_accounts get_account_history scorum -1 1000</p>
<p>(For some unknown reason, the current version of the wallet hangs after the transfer command &ndash; why?)</p>
<p>Again, we're not actually taking control of anything, we're doing a "what-if" experiment &ndash; what if the keys to this account had suddenly changed at block 1505 and then this transfer operation was broadcast? And we find out that the chain and the wallet handle the situation as exepected (processing the transfer, putting it in the account history, and updating the balance).</p>
<p>This plugin allows all sorts of creative "what-if" experiments with the chain. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 9 2022 13:04:27 for Scorum by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
